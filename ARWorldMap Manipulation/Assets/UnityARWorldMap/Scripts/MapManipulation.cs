using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Security.Policy;
using Tayx.Graphy;

namespace UnityEngine.XR.iOS
{ 
	
	/**
	 * @author Sinan Elveren
	 * Controller for reference point of model
	 */
	public class MapManipulation : MonoBehaviour
	{
		[SerializeField]
		private Transform cylinderPrefab;
		
		[SerializeField]
		private GameObject placedPrefab;

		public GameObject PlacedPrefab
		{
			get 
			{
				return placedPrefab;
			}
			set 
			{
				placedPrefab = value;
			}
		}
		
		
		public Transform m_HitTransform;
		public float maxRayDistance = 30.0f;
		public LayerMask collisionLayer = 1 << 10;  //ARKitPlane layer
		
		
		public GameObject carcassPrefab;
		private int objectCount = 0;
		private Vector3 top;
		private Vector3 right;
		private Vector3 left;
		private Vector3 back;
		
		public List<Transform> positions; 
		private Pose placementPose;

		private GameObject leftSphere;
		private GameObject rightSphere;
		private GameObject backSphere;
		private GameObject topSphere;
		
		
		private GameObject cylinder;
		private GameObject cylinderX;
		private GameObject cylinderY;
		private GameObject cylinderZ;

		private int count = 0;
		private float zScale;
		private float yScale;
		private float xScale;

		
		
		
		private void Start()
		{
			//var fps = GraphyManager.Instance.CurrentFPS;
			//GraphyDebugger.Instance.RemoveAllDebugPacketsWithId(2);
		}

		bool HitTestWithResultType (ARPoint point, ARHitTestResultType resultTypes)
		{
            List<ARHitTestResult> hitResults = UnityARSessionNativeInterface.GetARSessionNativeInterface ().HitTest (point, resultTypes);
            if (hitResults.Count > 0) {
                foreach (var hitResult in hitResults) {
                    Debug.Log ("Got hit!");
                    m_HitTransform.position = UnityARMatrixOps.GetPosition (hitResult.worldTransform);
                    m_HitTransform.rotation = UnityARMatrixOps.GetRotation (hitResult.worldTransform);
                    Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", m_HitTransform.position.x, m_HitTransform.position.y, m_HitTransform.position.z));
                    return true;
                }
            }
            return false;
        }
		
		// Update is called once per frame
		void Update () {
		//	#if UNITY_EDITOR   //we will only use this script on the editor side, though there is nothing that would prevent it from working on device
	
			
			if (Input.touchCount > 0 && m_HitTransform != null)
			{

				var touch = Input.GetTouch(0);
				if (touch.phase == TouchPhase.Began || touch.phase == TouchPhase.Moved)
				{
					objectCount++;

					var screenPosition = Camera.main.ScreenToViewportPoint(touch.position);
					ARPoint point = new ARPoint {
						x = screenPosition.x,
						y = screenPosition.y
					};

					// prioritize reults types
					ARHitTestResultType[] resultTypes = {
						//ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingGeometry,
						ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent, 
						// if you want to use infinite planes use this:
						//ARHitTestResultType.ARHitTestResultTypeExistingPlane,
						ARHitTestResultType.ARHitTestResultTypeEstimatedHorizontalPlane, 
						ARHitTestResultType.ARHitTestResultTypeEstimatedVerticalPlane, 
						ARHitTestResultType.ARHitTestResultTypeFeaturePoint
					}; 
						
					foreach (ARHitTestResultType resultType in resultTypes)
					{
						if (HitTestWithResultType (point, resultType))
						{
							return;
						}
					}

				}
		
		
		
/*			if (Input.GetMouseButtonDown (0))
			{
				objectCount++;
				Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);
				RaycastHit hit;
				
				//we'll try to hit one of the plane collider gameobjects that were generated by the plugin
				//effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
				if (Physics.Raycast(ray, out hit, maxRayDistance, collisionLayer))
				{
					//we're going to get the position from the contact point
					m_HitTransform.position = hit.point;
					Debug.Log(string.Format("x:{0:0.######} y:{1:0.######} z:{2:0.######}", m_HitTransform.position.x, 
						m_HitTransform.position.y, m_HitTransform.position.z));

					//and the rotation from the transform of the plane collider
					m_HitTransform.rotation = hit.transform.rotation;

					//placementPose.position = hit.point;
					//placementPose.rotation = hit.transform.rotation;




				}
*/

				if (objectCount == 1)
				{
					Instantiate(placedPrefab, m_HitTransform.position, m_HitTransform.rotation);

					/***/

					back =  m_HitTransform.position;
					Debug.Log("Back " + m_HitTransform.position);
            
					backSphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
					backSphere.transform.position = m_HitTransform.position;
					backSphere.transform.localScale = m_HitTransform.transform.localScale;
				}

				if (objectCount == 2)
				{
					left =  m_HitTransform.position;
                    
                    leftSphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                    leftSphere.transform.position = m_HitTransform.position;
                    leftSphere.transform.localScale = m_HitTransform.transform.localScale;
                }
                
                if (objectCount == 3)
                {
	                top =  m_HitTransform.position;
                    
                    topSphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                    topSphere.transform.position = m_HitTransform.position;
                    topSphere.transform.localScale = m_HitTransform.transform.localScale;
                }
                
                if (objectCount == 4)
                {
	                right =  m_HitTransform.position;
    
                    rightSphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
                    rightSphere.transform.position = m_HitTransform.position;
                    rightSphere.transform.localScale = m_HitTransform.transform.localScale;
                }

                if (objectCount == 5)
                {
                   drawEdges();

                   createAtCenter();


                } 
                
                if (objectCount > 5)
				{
					//objectCount = 0;
					Destroy(leftSphere);
					Destroy(rightSphere);
					Destroy(topSphere);
					Destroy(backSphere);
					Destroy(cylinderX);
					Destroy(cylinderY);
					Destroy(cylinderZ);
					
					Destroy(cylinder);
					Destroy(cylinderPrefab);
					Destroy(topSphere);
					Destroy(backSphere);
                
					carcassPrefab.SetActive(false);
                
					positions.Clear();
					carcassPrefab = Instantiate(carcassPrefab, m_HitTransform.position, Quaternion.identity);
					carcassPrefab.transform.position = m_HitTransform.position;
					carcassPrefab.transform.rotation= m_HitTransform.rotation;
				}
			}
			//#else
			/*
			if (Input.touchCount > 0 && m_HitTransform != null)
			{
				var touch = Input.GetTouch(0);
				if (touch.phase == TouchPhase.Began || touch.phase == TouchPhase.Moved)
				{
					var screenPosition = Camera.main.ScreenToViewportPoint(touch.position);
					ARPoint point = new ARPoint {
						x = screenPosition.x,
						y = screenPosition.y
					};

                    // prioritize reults types
                    ARHitTestResultType[] resultTypes = {
						//ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingGeometry,
                        ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent, 
                        // if you want to use infinite planes use this:
                        //ARHitTestResultType.ARHitTestResultTypeExistingPlane,
                        //ARHitTestResultType.ARHitTestResultTypeEstimatedHorizontalPlane, 
						//ARHitTestResultType.ARHitTestResultTypeEstimatedVerticalPlane, 
						//ARHitTestResultType.ARHitTestResultTypeFeaturePoint
                    }; 
					
                    foreach (ARHitTestResultType resultType in resultTypes)
                    {
                        if (HitTestWithResultType (point, resultType))
                        {
                            return;
                        }
                    }

				}
			}
			*/

		}

		
		
		private GameObject InstantiateCylinder(Transform cylinderPrefab, Vector3 beginPoint, Vector3 endPoint)
		{
			cylinder = Instantiate<GameObject>(cylinderPrefab.gameObject, Vector3.zero, Quaternion.identity);
			return UpdateCylinderPosition(cylinder, beginPoint, endPoint);
         
		}

		private GameObject UpdateCylinderPosition(GameObject cylinder, Vector3 beginPoint, Vector3 endPoint)
		{
			Vector3 offset = endPoint - beginPoint;
			Vector3 position = beginPoint + (offset / 2.0f);

			cylinder.transform.position = position;
			cylinder.transform.LookAt(beginPoint);
			Vector3 localScale = cylinder.transform.localScale;
			localScale.z = (endPoint - beginPoint).magnitude;

			localScale.x = cylinder.transform.localScale.x / 10;
			localScale.y = cylinder.transform.localScale.y / 10;
			cylinder.transform.localScale = localScale;

			count++;
			if (count == 1)
			{
				zScale = localScale.z;
			}
			if (count == 2)
			{
				yScale = localScale.z;
			}
			if (count == 3)
			{
				xScale = localScale.z;
				count = 0;
			}
			return cylinder;
		}
		
    void drawEdges()
    {
       /* xEdge = Vector3.Distance(left, right);
        yEdge = Vector3.Distance(left, top);
        zEdge = Vector3.Distance(left, back);
*/
        cylinderX = InstantiateCylinder(cylinderPrefab, left, right);
        cylinderY = InstantiateCylinder(cylinderPrefab, left, top);
        cylinderZ = InstantiateCylinder(cylinderPrefab, left, back);

        Vector3 top2;
        Vector3 back2;
        Vector3 rightBack;
        Vector3 topBack;

        //calculate other 4 corners point
        top2.x = right.x;  
        top2.y = top.y;        
        top2.z = right.z;             

        back2.y = top.y;     
        back2.z = back.z;      
        back2.x = back.x;     

        rightBack.x = back.x + (right.x - left.x); //(right.x); // + right.x) / 2;
        rightBack.z = back.z + (right.z - left.z); //(back.z);// + back.z) / 2;
        rightBack.y = (back.y + right.y) / 2;

        topBack.y = (top.y + top2.y) / 2;   // y + rightBack.y;
        topBack.z = rightBack.z;
        topBack.x = rightBack.x;

        
        //to calculate center position
        positions.Add(InstantiateCylinder(cylinderPrefab, right, top2).transform);
        positions.Add(InstantiateCylinder(cylinderPrefab, top, top2).transform);

        positions.Add(InstantiateCylinder(cylinderPrefab, back, back2).transform);
        positions.Add(InstantiateCylinder(cylinderPrefab, top, back2).transform);

        positions.Add(InstantiateCylinder(cylinderPrefab, back, rightBack).transform);
        positions.Add(InstantiateCylinder(cylinderPrefab, right, rightBack).transform);

        positions.Add(InstantiateCylinder(cylinderPrefab, rightBack, topBack).transform);
        positions.Add(InstantiateCylinder(cylinderPrefab, back2, topBack).transform);
        positions.Add(InstantiateCylinder(cylinderPrefab, top2, topBack).transform);
        positions.Add(cylinderX.transform);
        positions.Add(cylinderY.transform);
        positions.Add(cylinderZ.transform);
       // positions.Add(backSphere.transform);


        var rightSphere2 = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        var rightBackSphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        var rightBackSphereTop = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        var leftBackSphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        
        rightSphere2.transform.position = top2;
        rightBackSphere.transform.position = rightBack;
        rightBackSphereTop.transform.position = topBack;
        leftBackSphere.transform.position = back2;
        var localScale = placedPrefab.transform.localScale;
        rightSphere2.transform.localScale = localScale;
        rightBackSphere.transform.localScale = localScale;
        rightBackSphereTop.transform.localScale = localScale;
        leftBackSphere.transform.localScale = localScale;
    }

    
    
		
    void createAtCenter()
    {
        float x = 0, y = 0, z = 0;
        foreach (Transform p in positions)
        {
            x += p.position.x;
            y += p.position.y;
            z += p.position.z;
        }

        x /= positions.Count;
        y /= positions.Count;
        z /= positions.Count;
        Vector3 pos = new Vector3(x, y, z);

       
        
  
       var currentSize = carcassPrefab.GetComponent<Collider>().bounds.size;
        
   
        //      obj.transform.localScale = localScale;
     // **   pos.y = pos.y - yEdge / 2;
		 pos.y = pos.y + (float)0.5f;
		 
        carcassPrefab = Instantiate(carcassPrefab, pos, Quaternion.identity);
       

        var saveRotation = carcassPrefab.transform.eulerAngles;
        var rotationXZ = cylinderX.transform.eulerAngles;
        var rotationY = cylinderZ.transform.eulerAngles;
        carcassPrefab.transform.eulerAngles = new Vector3(rotationXZ.x, rotationXZ.y, rotationY.x); // x:z, y:y, z:x
    
     
        var targetSizeX = cylinderX.transform.lossyScale.z;
        var targetSizeY = cylinderZ.transform.lossyScale.z;
        var targetSizeZ = cylinderY.transform.lossyScale.z;
        //var current = obj.transform.lossyScale.z;
        float newSizeRatioX = targetSizeX / (currentSize.z + 0.001f);
        float newSizeRatioY = targetSizeY / (currentSize.y + 0.001f);
        float newSizeRatioZ = targetSizeZ / (currentSize.x + 0.001f);

        
        
        
     // carcassPrefab.transform.localScale = new Vector3( 0.5f *newSizeRatioY* (currentSize.y + 0.001f), 0.5f *newSizeRatioZ* (currentSize.x + 0.001f), 0.5f *newSizeRatioX* (currentSize.z + 0.001f));

     
     
     
     
     
        carcassPrefab.SetActive(true);    //new carcass
        
        // Quaternion rot = new Quaternion(rotationXZ.x, rotationXZ.y, rotationY.z, obj.transform.rotation.w);
       // obj.transform.SetPositionAndRotation(pos, rot );
       // obj.transform.localScale = scale;
       // Vector3 localScale = obj.transform.LookAt(leftSphere.transform.position);
    }
    
	
	}
}

